"""
TOTP 2FA Handler.

Handles Time-based One-Time Password (TOTP) two-factor authentication.
"""

from typing import List, Dict
import pyotp
from playwright.async_api import Page
from ..state_handler import StateHandler
from ..login_state_machine import LoginState


class Totp2FAHandler(StateHandler):
    """
    Handler for TOTP 2FA state.
    
    This handler:
    1. Detects the TOTP 2FA page
    2. Generates TOTP code from secret
    3. Fills in the code
    4. Clicks verify button
    """
    
    # Common selectors for TOTP input
    TOTP_INPUT_SELECTORS = [
        # 新版 Fluent UI 选择器（优先）
        'input[id^="floatingLabelInput"]',  # 匹配 floatingLabelInput5 等
        'input.fui-Input__input[type="text"]',  # Fluent UI 输入框
        
        # 旧版选择器
        'input[name="otc"]',
        'input[id="idTxtBx_SAOTCC_OTC"]',
        'input[type="tel"]',
        'input[aria-label*="code"]',
        'input[aria-label*="Code"]',
    ]
    
    VERIFY_BUTTON_SELECTORS = [
        # 新版 Fluent UI 选择器（优先）
        'button[type="submit"][data-testid="primaryButton"]',  # Fluent UI 主按钮
        'button.fui-Button[type="submit"]',  # Fluent UI 按钮类
        
        # 旧版选择器
        'input[type="submit"]',
        'input[id="idSubmit_SAOTCC_Continue"]',
        'button[type="submit"]',
        'button:has-text("Next")',
        'button:has-text("Verify")',
    ]
    
    # Selectors that indicate 2FA page
    TOTP_PAGE_INDICATORS = [
        'text=Enter the code from your authenticator app',
        'text=Enter the code generated by your authenticator app',  # 修复：实际页面文本
        'text=Enter code',
        'text=Verify your identity',
        'text=验证你的身份',  # 中文
        'text=输入代码',
        'div[data-value="PhoneAppOTP"]',  # Microsoft 特定
        'div[data-value="PhoneAppNotification"]',
        '[aria-label*="verification code"]',
        '[aria-label*="验证码"]',
        'h1:has-text("Enter the code")',  # 标题检测
    ]
    
    async def can_handle(self, page: Page) -> bool:
        """
        Check if current page is the TOTP 2FA page.

        Args:
            page: Playwright page object

        Returns:
            True if TOTP 2FA page detected
        """
        # 快速检查：先检查 URL
        url = page.url.lower()
        if "login" not in url and "microsoft" not in url:
            return False

        # Check for TOTP input field (reduced timeout for speed)
        for selector in self.TOTP_INPUT_SELECTORS:
            if await self.element_exists(page, selector, timeout=1000):
                self.logger.debug(f"TOTP input detected: {selector}")
                return True
        
        # Check for page text indicators
        for indicator in self.TOTP_PAGE_INDICATORS:
            try:
                element = await page.query_selector(indicator)
                if element:
                    self.logger.debug(f"TOTP page indicator found: {indicator}")
                    return True
            except Exception:
                pass
        
        return False
    
    async def handle(self, page: Page, credentials: Dict[str, str]) -> bool:
        """
        Handle TOTP 2FA by generating and entering code.
        
        Args:
            page: Playwright page object
            credentials: Must contain 'totp_secret' key
            
        Returns:
            True if successful
        """
        totp_secret = credentials.get('totp_secret')
        if not totp_secret:
            self.logger.error("No TOTP secret provided in credentials")
            return False
        
        self.logger.info("Handling TOTP 2FA")
        
        # Clean TOTP secret (remove spaces)
        totp_secret = totp_secret.replace(' ', '').replace('-', '')
        
        # Generate TOTP code
        try:
            totp = pyotp.TOTP(totp_secret)
            code = totp.now()
            self.logger.info(f"Generated TOTP code: {code[:3]}***")
        except Exception as e:
            self.logger.error(f"Failed to generate TOTP code: {e}")
            return False
        
        # Small delay before interaction (simulate reading the page)
        await self.human_simulator.human_delay(800, 1500)
        
        # Find and fill TOTP input with human-like typing
        filled = False
        for selector in self.TOTP_INPUT_SELECTORS:
            if await self.safe_fill(page, selector, code, timeout=5000, human_like=True):
                filled = True
                self.logger.debug(f"TOTP code filled using selector: {selector}")
                break
        
        if not filled:
            self.logger.error("Failed to fill TOTP input")
            # 保存诊断信息
            try:
                html = await page.content()
                import os
                from datetime import datetime
                os.makedirs("logs/diagnostics", exist_ok=True)
                filename = f"logs/diagnostics/totp_failed_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(html)
                self.logger.info(f"已保存 2FA 页面 HTML: {filename}")
            except Exception:
                pass
            return False
        
        # Delay after typing (simulate checking the code)
        await self.human_simulator.human_delay(500, 1000)
        
        # Click verify button with human-like behavior
        clicked = False
        for selector in self.VERIFY_BUTTON_SELECTORS:
            if await self.safe_click(page, selector, timeout=5000, human_like=True):
                clicked = True
                self.logger.info(f"✓ Verify button clicked using selector: {selector}")
                break
        
        if not clicked:
            self.logger.error("Failed to click verify button - all selectors failed")
            # 保存诊断信息
            try:
                html = await page.content()
                import os
                from datetime import datetime
                os.makedirs("logs/diagnostics", exist_ok=True)
                filename = f"logs/diagnostics/totp_button_failed_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(html)
                self.logger.info(f"已保存 2FA 按钮失败页面 HTML: {filename}")
                
                # 保存截图
                screenshot_path = f"logs/diagnostics/totp_button_failed_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                await page.screenshot(path=screenshot_path)
                self.logger.info(f"已保存截图: {screenshot_path}")
            except Exception as e:
                self.logger.debug(f"保存诊断信息失败: {e}")
            
            # 关键修复：点击失败必须返回 False
            return False
        
        # Wait for navigation
        await self.wait_for_navigation(page)
        
        # 保存 2FA 提交后的页面（用于诊断下一个状态）
        try:
            import os
            from datetime import datetime
            os.makedirs("logs/diagnostics", exist_ok=True)
            html = await page.content()
            filename = f"logs/diagnostics/totp_after_submit_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(html)
            self.logger.info(f"已保存 2FA 提交后页面 HTML: {filename}")
            
            # 同时保存截图
            screenshot_path = f"logs/diagnostics/totp_after_submit_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            self.logger.info(f"已保存 2FA 提交后截图: {screenshot_path}")
        except Exception as e:
            self.logger.debug(f"保存 2FA 后诊断信息失败: {e}")
        
        self.logger.info("TOTP 2FA handled successfully")
        return True
    
    def get_next_states(self) -> List[LoginState]:
        """
        Possible next states after TOTP 2FA.
        
        Returns:
            List of possible next states
        """
        return [
            LoginState.LOGGED_IN,
            LoginState.ERROR,
        ]
